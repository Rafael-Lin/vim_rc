" Variable
let mapleader=','
function! NeoCompleteFunction() "{
    "Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
                \ 'default' : '',
                \ 'vimshell' : $HOME.'/.vimshell_hist',
                \ 'dict' : $VIM.'/word/wordsEn',
                \ 'scheme' : $HOME.'/.gosh_completions'
                \ }

"    let g:neocomplete#sources.tex = ['buffer', 'dictionary' , 'file' ] ", 'ultisnips', 'file',
                " \ 'omni']
                " 
    " if !exists('g:neocomplete#sources')
		  " let g:neocomplete#sources = {}
		" endif
    " let g:neocomplete#sources._ = ['buffer', 'dictionary', 'dict', 'file']
    " let g:neocomplete#sources.cs = ['buffer', 'dictionary', 'dict']

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'


    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function() "{
        return neocomplete#close_popup() . "\<CR>"
        " For no inserting <CR> key.
        "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
    endfunction "}
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()
    " Close popup by <Space>.
    "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

    " For cursor moving in insert mode(Not recommended)
    "inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
    "inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
    "inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
    "inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
    " Or set this.
    "let g:neocomplete#enable_cursor_hold_i = 1
    " Or set this.
    "let g:neocomplete#enable_insert_char_pre = 1

    " AutoComplPop like behavior.
    "let g:neocomplete#enable_auto_select = 1

    " Shell like behavior(not recommended).
    "set completeopt+=longest
    "let g:neocomplete#enable_auto_select = 1
    "let g:neocomplete#disable_auto_complete = 1
    "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns = {}
    endif
    "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
    let g:neocomplete#enable_at_startup = 1 
    let g:neocomplcache_tags_caching_limit_file_size = 50000 
endfunction "}

function! ToggleVerbose() "{
    if !&verbose
        set verbosefile=d:\verbose.log
        set verbose=15
    else
        set verbose=0
        set verbosefile=
    endif
endfunction "}
function! FontSizeSetting_func() "{
    " map <F2>  :call SetFMDIndent() <ESC>:set foldlevel=0<CR>
    " map <F3>  :call SetFMDIndent() <ESC>:set foldlevel=1<CR>
    " map <F4>  :call SetFMDIndent() <ESC>:set foldlevel=2<CR>
    " map <F5>  :call SetFMDIndent() <ESC>:set foldlevel=3<CR>
    " map <F6>  :call SetFMDIndent() <ESC>:set foldlevel=4<CR>

    nmap <leader>f0 :set foldlevel=0<CR>
    nmap <leader>f1 :set foldlevel=1<CR>
    nmap <leader>f2 :set foldlevel=2<CR>
    nmap <leader>f3 :set foldlevel=3<CR>
    nmap <leader>f4 :set foldlevel=4<CR>
    nmap <leader>f5 :set foldlevel=5<CR>
    nmap <leader>f6 :set foldlevel=6<CR>
    nmap <leader>f7 :set foldlevel=7<CR>
    nmap <leader>f8 :set foldlevel=8<CR>
    nmap <leader>f9 :set foldlevel=9<CR>

    map <F9>  <ESC>:set guifont=Monaco:h10<ESC>:winpos 0 0<CR>:set lines=100 columns=100<CR>:set nowrap<CR>
    map <F10> <ESC>:set guifont=Monaco:h12<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
    map <F11> <ESC>:set guifont=Monaco:h16<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
    map <F12> <ESC>:set guifont=Monaco:h24<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
endfunction "}
function! SetChineseFont_func() "{
    return 
    set gfw=Microsoft_Yahei_Mono:h24:cGB2312<CR>
endfunction "}
function! Vundle_func() "{
    set nocompatible              " be iMproved, required
    filetype off                  " required

    " set the runtime path to include Vundle and initialize
    set rtp+=D:\\Vim74\\complete-x64\\vimfiles\\bundle\\Vundle.vim
    "call vundle#begin()
    " alternatively, pass a path where Vundle should install plugins
    call vundle#begin('D:\\Vim74\\complete-x64\\vimfiles\\bundle\')

    " let Vundle manage Vundle, required
    "Plugin 'Valloric/YouCompleteMe'
    "Plugin 'SirVer/ultisnips'
    "Plugin 'honza/vim-snippets'
    "Plugin 'mattn/emmet-vim'
    "Plugin 'pangloss/vim-javascript'
    "Plugin 'othree/html5.vim'
    "
    " Plugin 'ack.vim'
    "Plugin 'vim-scripts/TaskList.vim'
    Plugin 'scrooloose/nerdtree'
    Plugin 'commentary.vim'
    Plugin 'kien/ctrlp.vim'
    Plugin 'matchit.zip'
    Plugin 'gmarik/Vundle.vim'
    Plugin 'Shougo/neocomplete.vim'
    " Plugin 'file:///D:/Vim74/Vim/vimfiles/bundle/molokai'
    " Plugin 'file:///D:/Vim74/Vim/vimfiles/bundle/nerdtree'
    " Plugin 'SuperTab'
    Plugin 'surround.vim'
    Plugin 'Tabular'
    Plugin 'EasyMotion'
    Plugin 'sjl/gundo.vim'
    Plugin 'taglist.vim'
    Plugin 'bling/vim-airline'
    Plugin 'altercation/solarized'
    Plugin 'tpope/vim-fugitive'
    "Plugin 'majutsushi/tagbar'
    " Plugin 'Solarized'

    " All of your Plugins must be added before the following line
    call vundle#end()            " required
    filetype plugin indent on    " required
    " To ignore plugin indent changes, instead use:
    "filetype plugin on
    "
    " Brief help
    " :PluginList       - lists configured plugins
    " :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
    " :PluginSearch foo - searches for foo; append `!` to refresh local cache
    " :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
    "
    " see :h vundle for more details or wiki for FAQ
    " Put your non-Plugin stuff after this line
endfunction "}
function! Win_short_cut_func() "{
    if has('win32')
        nmap ,cs :let @*=substitute(expand("%"), "/", "\\", "g")<CR> 
        "filename
        nmap ,cl :let @*=substitute(expand("%:p"), "/", "\\", "g")<CR>
        "filepath
        nmap ,ci :silent !explorer %:p:h:gs?\/?\\\\\\?<CR>
        "open file folder
        map  ,ci :!start explorer %:p:h:gs?\/?\\\\\\?<CR>
    endif
endfunction "}
function! AddIndentFunc() "{
    vnoremap < <gv
    vnoremap > >gv
endfunction "}
function! Tab_Or_Complete() "{
    if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
        return "\<C-N>"
    else
        return "\<Tab>"
    endif
endfunction "}
function! Layout_func() "{
    "set nowrap
    " set	softtabstop=4
    " set modeline
    " let g:molokai_original = 1
    " let g:rehash256 = 1
    "set wrap             "
    set number
    set	showcmd 
    set	shiftwidth=4
    set expandtab " change tab into space
    set	tabstop=4
    set	noeb ruler
    set	backspace=indent,eol,start
    set	history=60
    set wildmenu
    if has('gui_running')
        colors solarized 
    else
        colorscheme desert
    endif

    set t_Co=256          " 256 color mode
    set cursorline        " highlight current line
    set ruler             " show the cursor position all the time
    syntax on             " syntax highlight
    set hlsearch          " search highlighting
    set clipboard=unnamed " yank to the system register (*) by default
    set showmatch         " Cursor shows matching ) and 
    set showmode          " Show current mode
    set wildchar=<TAB>    " start wild expansion in the command line using <TAB>
    set incsearch         " incremental search . Show result before finished typing
    set nobackup          " no *~ backup files
    set noswapfile
    set ignorecase        " ignore case when searching
    set nowritebackup
    set smartcase         " ignore case if search pattern is all lowercase,case-sensitive otherwise
    set smarttab          " insert tabs on the start of a line according to context
    " ignore these files while expanding wild chars
    language mes en
    set wildignore=*.o,*.class
    set cindent
    " set ai          " auto indent
    "set smartindent
    " disable sound on errors
    set noerrorbells
    set visualbell
    set t_vb=
    set tm=500
    set laststatus=2
    filetype plugin on
    " These are files we are not likely to want to edit or read.
    set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
    syntax on
    filetype plugin indent on
    set nocompatible
    set go= "guioptions
    "set go+=m
    " set guioptions-=m  "remove menu bar
    " set guioptions-=T  "remove toolbar
    " set guioptions-=r  "remove right-hand scroll bar
    " set guioptions-=L  "remove left-hand scroll bar
endfunction "}
function! Browser() "{
    let $PATH = $PATH . ';C:\Program Files (x86)\Google\Chrome\Application\'
    let line0 = getline (".")
    let line = matchstr (line0, "http[^ ]*")
    :if line==""
    let line = matchstr (line0, "ftp[^ ]*")
    :endif
    :if line==""
    let line = matchstr (line0, "file[^ ]*")
    :endif
    let line = escape (line, "#?&;|%")
    echo line
    exec ':silent !chrome.exe '. "\"" . line . "\""
endfunction "}
function! Autocmd_func() "{
    set autoread		" auto read when file is changed from outside
    " autocmd! bufwritepost .vimrc source ~/.vimrc " auto reload vimrc when editing it
    autocmd BufEnter * silent! lcd %:p:h
    " autocmd BufEnter * set nowrap
    "lcd : local cd
    "%   : the name of the current file
    "%p  : give its full path
    "%:p:h : its dir
endfunction "}
function! Map_func() "{
    cmap cd. lcd %:p:h " :cd. change working directory to that of the current file
    map <leader>w :call Browser ()<CR>
    nnoremap ,cd :cd %:p:h<CR>:pwd<CR>

    "Open in new tab (ctrl+t)
    map <silent> <C-E>  : browse tabnew<CR> 
    "map <silent> <C-E>  : browse edit<CR> 

    "Open one new empty tab
    "map \<c-t> : tabnew<CR>
    map <leader><c-w> : tabclose<CR>
    map <leader>G gg=G<CR>

    " Save all files
    map <silent> <C-S> : wa<CR> 
    imap <C-S> <ESC>   : wa<CR>

    "Close one tab
    map <C-q> :q!<CR>

    "Close all tabs
    map ,qa            : qa!<CR>
    "quick fix moving
    map <leader>n      : cn<CR>
    map <leader>p      : cp<CR>
    "move back and forward around tabs
    map <S-H> gT
    map <S-L> gt

    nnoremap <silent> ,d :set operatorfunc=DeleteEmptyLines<CR>m"g@
    map <leader>c :call CalWordCount()<cr>
    nmap <Leader>db :g/^$/d<CR>
    imap ]] <ESC><CR>
    nmap ]] <ESC><CR>
    " inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
    map <leader>z V%zf
    "map <leader>d I(Done). <ESC>
    "map <leader>og I(On-going). <ESC>

    " CTRL-A is Select all
    " noremap qq<C-A> gggH<C-O>G
    " inoremap qq<C-A> <C-O>gg<C-O>gH<C-O>G
    " cnoremap qq<C-A> <C-C>gggH<C-O>G
    " onoremap qq<C-A> <C-C>gggH<C-O>G
    " snoremap qq<C-A> <C-C>gggH<C-O>G
    " xnoremap qq<C-A> <C-C>ggVG
endfunction "}
function! SetFMDIndent() "{
    set foldmethod=marker
    set foldmarker={,}
endfunction "}
function! Fold_func() "{
    set foldmethod=marker
    set foldmarker={,}
    set foldlevel=0 "Default level number
    set foldcolumn=2 "Default column number
endfunction "}
function! Path_assign_func() "{
    set backupdir=$VIM\\BackUp
    set dir=$VIM\\BackUp
endfunction "}
function! Supertab_func() "{
    let g:SuperTabMappingForward="<s-tab>"
    let g:SuperTabMappingBackward="<tab>"
    let g:SuperTabDefaultCompletionType = "context"
    "let g:SuperTabContextDefaultCompletionType = "<c-x><c-p>"
    "let g:SuperTabDefaultCompletionType = ‘<C-X><C-U>
endfunction "}
function! Complete_func() "{
    set completeopt=longest,menuone
    set thesaurus+=$VIM\word\test.txt
    set dictionary+=$VIM\word\wordsEn.txt
    set complete +=w,s,k,.,b,t
endfunction   "}
function! Nerdtree_func () "{
    nmap <leader>e	:NERDTreeToggle<CR>
    let g:NERDTreeWinPos    = "right"
    let NERDTreeHijackNetrw = 0
endfunction   "}
function! Ctrlp_func() "{
    noremap  <C-W><C-U> : CtrlPMRU <CR>
    " nnoremap  <C-W> u   : CtrlPMRU <CR>
    let g:ctrlp_custom_ignore         = '\.git$\|\.hg$\|\.svn$ \|.rvm$'
    let g:ctrlp_working_path_mode     = 0
    let g:ctrlp_match_window_bottom   = 1
    let g:ctrlp_max_height            = 15
    let g:ctrlp_match_window_reversed = 0
    let g:ctrlp_mruf_max              = 500
    let g:ctrlp_follow_symlinks       = 1
endfunction "}
function! View_init() "{
    autocmd BufWinLeave *.* mkview
    autocmd BufWinEnter *.* silent loadview 
endfunction "}
function! DragCurrentLineFunc() "{
    noremap  <A-j> :m+<CR>
    noremap  <A-k> :m-2<CR>
    inoremap <A-j> <Esc>:m+<CR>
    inoremap <A-k> <Esc>:m-2<CR>
    vnoremap <A-j> :m'>+<CR>gv
endfunction "}
function! View_init_second() "{
    set viewoptions-=options
    augroup vimrc
        autocmd BufWritePost *
                    \   if expand('%') != '' && &buftype !~ 'nofile'
                    \|      mkview
                    \|  endif
        autocmd BufRead *
                    \   if expand('%') != '' && &buftype !~ 'nofile'
                    \|      silent loadview
                    \|  endif
    augroup END
endfunction "}
function! DiffFunc() "{
    set diffexpr=
    map <silent> <C-V><C-F> :browse vert diffsplit<CR> 
    " find one file to compare
endfunction "}
function! TabularFunc() "{
     nmap <Leader>a& :Tabularize /&<CR>
     vmap <Leader>a& :Tabularize /&<CR>
     nmap <Leader>a= :Tabularize /=<CR>
     vmap <Leader>a= :Tabularize /=<CR>
     nmap <Leader>a: :Tabularize /:<CR>
     vmap <Leader>a: :Tabularize /:<CR>
     nmap <Leader>a:: :Tabularize /:\zs<CR>
     vmap <Leader>a:: :Tabularize /:\zs<CR>
     nmap <Leader>a, :Tabularize /,<CR>
     vmap <Leader>a, :Tabularize /,<CR>
     nmap <Leader>a,, :Tabularize /,\zs<CR>
     vmap <Leader>a,, :Tabularize /,\zs<CR>
     nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
     vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
endfunction "}
function! CommandLineFunc() "{
    " cnoremap <C-j> <t_kd>
    " cnoremap <C-k> <t_ku>
    " cnoremap <C-a> <Home>
    " cnoremap <C-e> <End>
    cmap <C-a> <Home>
    cmap <C-e> <End>
endfunction "}
function! AckFunc() "{
    nmap	<leader>g:noautocmd ack /<C-R>=expand("<cword>")<CR>/ *.*<CR>
    nnoremap <C-H>  :noautocmd vimgrep /<C-R>=expand("<cword>")<CR>/ $solution_source_path<CR>:copen
    " nnoremap <C-G>  :Ack <C-R>=expand("<cword>")<CR> 'D:\Code\DesignStudioNG\Source\' --type=csharp --type=cc --type=sql --type=vb
endfunction "}
function! NumberToggle()  "{
    if(&relativenumber == 1)
        set number
    else
        set relativenumber
    endif
endfunc "}
function! TagbarFunc() "{
    nmap <F7> <Esc>:!ctags -R *<CR>
    nmap <F8> :TagbarToggle<CR>
    let g:tagbar_left      = 1
    "set tags=..\..\tags,..\..\..\tags,.\tags
    let Tlist_Ctags_Cmd    = $VIM . '\vim74\ctags.exe'
    let g:tagbar_autofocus = 1
    nmap	,ti :Tlist<CR>
endfunction "}
function! LayoutFunc() "{
    set guifont=Monaco:h10 
    set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
    set splitright                  " Puts new vsplit windows to the right of the current
    :winpos 0 0
    set lines=999 columns=999
endfunction "}
function! CalWordCount() "{
    let l:cmd = []
    let l:cmd = add(l:cmd, '%s/')
    let l:cmd = add(l:cmd, '\(')
    let l:cmd = add(l:cmd, '[')
    let l:cmd = add(l:cmd, '\u3001-\u303f') 
    let l:cmd = add(l:cmd, '\u3040-\u309f')
    let l:cmd = add(l:cmd, '\u30a0-\u30ff')
    let l:cmd = add(l:cmd, '\u3100-\u312f')
    let l:cmd = add(l:cmd, '\u31a0-\u31bf')
    let l:cmd = add(l:cmd, '\u4e00-\u4eff\u4f00-\u4fff\u5000-\u50ff\u5100-\u51ff\u5200-\u52ff\u5300-\u53ff\u5400-\u54ff\u5500-\u55ff\u5600-\u56ff\u5700-\u57ff\u5800-\u58ff\u5900-\u59ff\u5a00-\u5aff\u5b00-\u5bff\u5c00-\u5cff\u5d00-\u5dff\u5e00-\u5eff\u5f00-\u5fff\u6000-\u60ff\u6100-\u61ff\u6200-\u62ff\u6300-\u63ff\u6400-\u64ff\u6500-\u65ff\u6600-\u66ff\u6700-\u67ff\u6800-\u68ff\u6900-\u69ff\u6a00-\u6aff\u6b00-\u6bff\u6c00-\u6cff\u6d00-\u6dff\u6e00-\u6eff\u6f00-\u6fff\u7000-\u70ff\u7100-\u71ff\u7200-\u72ff\u7300-\u73ff\u7400-\u74ff\u7500-\u75ff\u7600-\u76ff\u7700-\u77ff\u7800-\u78ff\u7900-\u79ff\u7a00-\u7aff\u7b00-\u7bff\u7c00-\u7cff\u7d00-\u7dff\u7e00-\u7eff\u7f00-\u7fff\u8000-\u80ff\u8100-\u81ff\u8200-\u82ff\u8300-\u83ff\u8400-\u84ff\u8500-\u85ff\u8600-\u86ff\u8700-\u87ff\u8800-\u88ff\u8900-\u89ff\u8a00-\u8aff\u8b00-\u8bff\u8c00-\u8cff\u8d00-\u8dff\u8e00-\u8eff\u8f00-\u8fff\u9000-\u90ff\u9100-\u91ff\u9200-\u92ff\u9300-\u93ff\u9400-\u94ff\u9500-\u95ff\u9600-\u96ff\u9700-\u97ff\u9800-\u98ff\u9900-\u99ff\u9a00-\u9aff\u9b00-\u9bff\u9c00-\u9cff\u9d00-\u9dff\u9e00-\u9eff\u9f00-\u9fff')
    let l:cmd = add(l:cmd, '\ufe10-\ufe1f')
    let l:cmd = add(l:cmd, '\uff00-\uffef')
    let l:cmd = add(l:cmd, ']')
    let l:cmd = add(l:cmd, '\|')
    let l:cmd = add(l:cmd, '\<\w*\>')
    let l:cmd = add(l:cmd, '\)')
    let l:cmd = add(l:cmd, '/&/gn')
    exe join(l:cmd, '')
    map c :call CalWordCount()
endfunction "}
function! Complete_test_func() "{
    let g:neocomplcache_enable_at_startup = 1
endfunction "}
function! BinaryViewFunc() "{
    nmap ,b  :%! xxd
    nmap ,br :%! xxd -r
endfunction "}
function! DeleteEmptyLines(type) "{
    if a:type == 'line'
        silent execute ".,'\"g/^$/d"
    endif
endfunction "}
function! Airline_func() "{
    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tabline#left_sep = ' '
    let g:airline#extensions#tabline#left_alt_sep = '|'

    " enable tabline
    let g:airline#extensions#tabline#enabled = 1
    " set left separator
    let g:airline#extensions#tabline#left_sep = ' '
    " set left separator which are not editting
    let g:airline#extensions#tabline#left_alt_sep = '|'
    " show buffer number
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline_theme='wombat'

    let g:airline_section_b = '%{getcwd()}'
    "let g:airline_section_c = '%t'

    "let g:airline#extensions#tagbar#enabled = 1
    " let g:airline#extensions#tagbar#flags = ''
endfunction "}
function! AccentDemo() "{
    " let keys = ['a','b','c','d','e','f','g','h']
    " for k in keys
    "   call airline#parts#define_text(k, k)
    " endfor
    let g:airline_section_a = 'Be the Man'
endfunction "}
function! TaskList() "{
    map <leader>tl <Plug>TaskList
endfunction "}
function! NetrwFunc() "{
    let g:netrw_liststyle=3
    let g:netrw_preview = 1 " use p to preview the file content
    nmap	qqe :Explore .<CR>
    " <cr>       Netrw will enter the directory or read the file 
    " <del>      Netrw will attempt to remove the file/directory                                                                
    " D        Attempt to remove the file(s)/directory(ies)                            
    " o        Enter the file/directory under the cursor in a new  browser window.  A horizontal split is used.
    " O        Obtain a file specified by cursor                    
    " p        Preview the file                                     
    " P        Browse in the previously used window                            
    " qf       Display information on file                                                         
    " R        Rename the designed file(s)/directory(ies)            
    " t        Enter the file/directory under the cursor in a new tab           
    " v        Enter the file/directory under the cursor in a new browser window.  A vertical split is used.
    " x        View file with an associated program                 
    " %        Open a new file in netrw's current directory     
endfunction "}
function! GundoFunc() "{
    nnoremap <Leader>u :GundoToggle<CR>
endfunction "}
function! UltisnipsFunc() "{
    " Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
    let g:UltiSnipsExpandTrigger="<tab>"
    let g:UltiSnipsJumpForwardTrigger="<c-b>"
    let g:UltiSnipsJumpBackwardTrigger="<c-z>"

    " If you want :UltiSnipsEdit to split your window.
    let g:UltiSnipsEditSplit="vertical"
endfunction "}

" execute functions
" call UltisnipsFunc()
call ToggleVerbose()
call Vundle_func()
call NeoCompleteFunction() 
call Airline_func()
call BinaryViewFunc()
"call TagbarFunc()
call DiffFunc()
call FontSizeSetting_func()
call Autocmd_func()
call Fold_func()
call Path_assign_func()
" call Supertab_func()
call Complete_func()
call Nerdtree_func()
call View_init_second()
call Complete_test_func()
call TabularFunc()
call CommandLineFunc()
call Layout_func()
call Win_short_cut_func()
call Map_func()
call Ctrlp_func()
call AckFunc()
call LayoutFunc()
call GundoFunc()
call DragCurrentLineFunc()
call AddIndentFunc()
call NetrwFunc()
"call TaskList()
set textwidth=300 
autocmd BufEnter *.* set nowrap
set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<

autocmd VimEnter * call AccentDemo()
"known key word
" try to know <SID>
"
"
"
    " set background=dark         " Assume a dark background
    " " Allow to trigger background
    " function! ToggleBG()
    "     let s:tbg = &background
    "     " Inversion
    "     if s:tbg == "dark"
    "         set background=light
    "     else
    "         set background=dark
    "     endif
    " endfunction
    " noremap <leader>bg :call ToggleBG()<CR>
    "
