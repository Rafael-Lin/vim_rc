" Variable
let $open_path = $VIM . '\script\open.vim'
let $test_path = $VIM . '\script\test.vim'
let $solution_source_path = 'D:\Code\DesignStudioNG\Source\**\*.cs'
let $solution_path = 'D:\Code\DesignStudioNG\Source\'
let mapleader=','
function! ToggleVerbose()
    if !&verbose
        set verbosefile=d:\verbose.log
        set verbose=15
    else
        set verbose=0
        set verbosefile=
    endif
endfunction
function FontSizeSetting_func()
    map <F2>  :call SetFMDIndent() <ESC>:set foldlevel=1<CR>
    map <F3>  :call SetFMDIndent() <ESC>:set foldlevel=2<CR>
    map <F4>  :call SetFMDIndent() <ESC>:set foldlevel=3<CR>
    map <F5>  :call SetFMDIndent() <ESC>:set foldlevel=4<CR>

    map <F9>  <ESC>:set guifont=Monaco:h10<ESC>:winpos 0 0<CR>:set lines=20 columns=100<CR>:set nowrap<CR>
    "map <F9>  <ESC>:set guifont=Monaco:h10<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
    map <F10> <ESC>:set guifont=Monaco:h12<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
    map <F11> <ESC>:set guifont=Monaco:h16<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
    map <F12> <ESC>:set guifont=Monaco:h24<ESC> :call SetChineseFont_func()<CR>:winpos 0 0<CR>:set lines=999 columns=999<CR>
endfunction
function SetChineseFont_func()
    return 
    set gfw=Microsoft_Yahei_Mono:h24:cGB2312<CR>
endfunction
function Vundle_func()
    set nocompatible              " be iMproved, required
    filetype off                  " required

    " set the runtime path to include Vundle and initialize
    set rtp+=D:\\Vim74\\complete-x64\\vimfiles\\bundle\\Vundle.vim
    " call vundle#begin()
    " alternatively, pass a path where Vundle should install plugins
    call vundle#begin('D:\\Vim74\\complete-x64\\vimfiles\\bundle\')

    " let Vundle manage Vundle, required
    Plugin 'gmarik/Vundle.vim'
    " Plugin 'nerdtree'
    " Plugin 'scrooloose/nerdtree'
    " Plugin 'vim-easymotion'
    Plugin 'ack.vim'
    Plugin 'commentary.vim'
    Plugin 'https://github.com/scrooloose/nerdtree.git'
    Plugin 'kien/ctrlp.vim'
    Plugin 'matchit.zip'
    Plugin 'molokai'
    "Plugin 'Tagbar'
    "Plugin 'Powerline'
    Plugin 'SuperTab'
    Plugin 'surround.vim'
    Plugin 'Tabular'
    Plugin 'taglist.vim'
    Plugin 'VisIncr'
    Plugin 'bling/vim-airline'
    Plugin 'altercation/solarized'
    " The following are examples of different formats supported.
    " Keep Plugin commands between vundle#begin/end.
    " plugin on GitHub repo
    "Plugin 'tpope/vim-fugitive'
    " plugin from http://vim-scripts.org/vim/scripts.html
    "Plugin 'L9'
    " Git plugin not hosted on GitHub
    "Plugin 'git://git.wincent.com/command-t.git'
    " git repos on your local machine (i.e. when working on your own plugin)
    "Plugin 'file:///home/gmarik/path/to/plugin'
    " The sparkup vim script is in a subdirectory of this repo called vim.
    " Pass the path to set the runtimepath properly.
    "Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
    " Avoid a name conflict with L9
    "Plugin 'user/L9', {'name': 'newL9'}

    " All of your Plugins must be added before the following line
    call vundle#end()            " required
    filetype plugin indent on    " required
    " To ignore plugin indent changes, instead use:
    "filetype plugin on
    "
    " Brief help
    " :PluginList       - lists configured plugins
    " :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
    " :PluginSearch foo - searches for foo; append `!` to refresh local cache
    " :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
    "
    " see :h vundle for more details or wiki for FAQ
    " Put your non-Plugin stuff after this line
endfunction
function Pathogen_func()
    let g:pathogen_disabled = []
    if !has('gui_running')
        call add(g:pathogen_disabled, 'powerline')
    endif
    call pathogen#runtime_append_all_bundles()
    call pathogen#helptags()
endfunction
function Win_short_cut_func()
    if has('win32')
        nmap ,cs :let @*=substitute(expand("%"), "/", "\\", "g")<CR> 
        "filename
        nmap ,cl :let @*=substitute(expand("%:p"), "/", "\\", "g")<CR>
        "filepath
        nmap ,ci :silent !explorer %:p:h:gs?\/?\\\\\\?<CR>
        "open file folder
        map  ,ci :!start explorer %:p:h:gs?\/?\\\\\\?<CR>
    endif
endfunction
function SyntasticFunc()
    set statusline+=%#warningmsg#
    set statusline+=%{SyntasticStatuslineFlag()}
    set statusline+=%*

    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_check_on_open = 1
    let g:syntastic_check_on_wq = 0
endfunction
function AddIndentFunc()
    vnoremap << gv
    vnoremap >> gv
endfunction
function OmniSharpVimFunc()
    let g:OmniSharp_selector_ui = 'ctrlp'
    " OmniSharp won't work without this setting
    filetype plugin on

    "This is the default value, setting it isn't actually necessary
    let g:OmniSharp_host = "http://localhost:2000"

    "Set the type lookup function to use the preview window instead of the status line
    "let g:OmniSharp_typeLookupInPreview = 1

    "Timeout in seconds to wait for a response from the server
    let g:OmniSharp_timeout = 1

    "Showmatch significantly slows down omnicomplete
    "when the first match contains parentheses.
    set noshowmatch

    "Super tab settings - uncomment the next 4 lines
    "let g:SuperTabDefaultCompletionType = 'context'
    "let g:SuperTabContextDefaultCompletionType = "<c-x><c-o>"
    "let g:SuperTabDefaultCompletionTypeDiscovery = ["&omnifunc:<c-x><c-o>","&completefunc:<c-x><c-n>"]
    "let g:SuperTabClosePreviewOnPopupClose = 1

    "don't autoselect first item in omnicomplete, show if only one item (for preview)
    "remove preview if you don't want to see any documentation whatsoever.
    set completeopt=longest,menuone,preview
    " Fetch full documentation during omnicomplete requests.
    " There is a performance penalty with this (especially on Mono)
    " By default, only Type/Method signatures are fetched. Full documentation can still be fetched when
    " you need it with the :OmniSharpDocumentation command.
    " let g:omnicomplete_fetch_documentation=1

    "Move the preview window (code documentation) to the bottom of the screen, so it doesn't move the code!
    "You might also want to look at the echodoc plugin
    set splitbelow

    " Get Code Issues and syntax errors
    let g:syntastic_cs_checkers = ['syntax', 'semantic', 'issues']
    " If you are using the omnisharp-roslyn backend, use the following
    " let g:syntastic_cs_checkers = ['code_checker']
    augroup omnisharp_commands
        autocmd!

        "Set autocomplete function to OmniSharp (if not using YouCompleteMe completion plugin)
        autocmd FileType cs setlocal omnifunc=OmniSharp#Complete

        " Synchronous build (blocks Vim)
        "autocmd FileType cs nnoremap <F5> :wa!<cr>:OmniSharpBuild<cr>
        " Builds can also run asynchronously with vim-dispatch installed
        autocmd FileType cs nnoremap <leader>b :wa!<cr>:OmniSharpBuildAsync<cr>
        " automatic syntax check on events (TextChanged requires Vim 7.4)
        autocmd BufEnter,TextChanged,InsertLeave *.cs SyntasticCheck

        " Automatically add new cs files to the nearest project on save
        autocmd BufWritePost *.cs call OmniSharp#AddToProject()

        "show type information automatically when the cursor stops moving
        autocmd CursorHold *.cs call OmniSharp#TypeLookupWithoutDocumentation()

        "The following commands are contextual, based on the current cursor position.

        autocmd FileType cs nnoremap gd :OmniSharpGotoDefinition<cr>
        autocmd FileType cs nnoremap <leader>fi :OmniSharpFindImplementations<cr>
        autocmd FileType cs nnoremap <leader>ft :OmniSharpFindType<cr>
        autocmd FileType cs nnoremap <leader>fs :OmniSharpFindSymbol<cr>
        autocmd FileType cs nnoremap <leader>fu :OmniSharpFindUsages<cr>
        "finds members in the current buffer
        autocmd FileType cs nnoremap <leader>fm :OmniSharpFindMembers<cr>
        " cursor can be anywhere on the line containing an issue
        autocmd FileType cs nnoremap <leader>x  :OmniSharpFixIssue<cr>
        autocmd FileType cs nnoremap <leader>fx :OmniSharpFixUsings<cr>
        autocmd FileType cs nnoremap <leader>tt :OmniSharpTypeLookup<cr>
        autocmd FileType cs nnoremap <leader>dc :OmniSharpDocumentation<cr>
        "navigate up by method/property/field
        autocmd FileType cs nnoremap <C-K> :OmniSharpNavigateUp<cr>
        "navigate down by method/property/field
        autocmd FileType cs nnoremap <C-J> :OmniSharpNavigateDown<cr>

    augroup END


    " this setting controls how long to wait (in ms) before fetching type / symbol information.
    set updatetime=500
    " Remove 'Press Enter to continue' message when type information is longer than one line.
    set cmdheight=2

    " Contextual code actions (requires CtrlP or unite.vim)
    nnoremap <leader><space> :OmniSharpGetCodeActions<cr>
    " Run code actions with text selected in visual mode to extract method
    vnoremap <leader><space> :call OmniSharp#GetCodeActions('visual')<cr>

    " rename with dialog
    nnoremap <leader>nm :OmniSharpRename<cr>
    nnoremap <F2> :OmniSharpRename<cr>
    " rename without dialog - with cursor on the symbol to rename... ':Rename newname'
    command! -nargs=1 Rename :call OmniSharp#RenameTo("<args>")

    " Force OmniSharp to reload the solution. Useful when switching branches etc.
    nnoremap <leader>rl :OmniSharpReloadSolution<cr>
    nnoremap <leader>cf :OmniSharpCodeFormat<cr>
    " Load the current .cs file to the nearest project
    nnoremap <leader>tp :OmniSharpAddToProject<cr>

    " (Experimental - uses vim-dispatch or vimproc plugin) - Start the omnisharp server for the current solution
    nnoremap <leader>ss :OmniSharpStartServer<cr>
    nnoremap <leader>sp :OmniSharpStopServer<cr>

    " Add syntax highlighting for types and interfaces
    nnoremap <leader>th :OmniSharpHighlightTypes<cr>
    "Don't ask to save when changing buffers (i.e. when jumping to a type definition)
    set hidden
endfunction
function Snippet_func()
    set runtimepath+=$VIM\snippets\after
    set runtimepath+=$VIM\snippets
    let g:snip_start_tag = "<"
    let g:snip_end_tag = ">"
    let g:snipMateAllowMatchingDot = 0
endfunction
function! Tab_Or_Complete()
    if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
        return "\<C-N>"
    else
        return "\<Tab>"
    endif
endfunction
function CommantT_func()
    let g:CommandTMaxHeight = 15
endfunction
function EasyMotion_func()
    let g:EasyMotion_leader_key = '<Leader>m' " default is <Leader>w
    hi link EasyMotionTarget ErrorMsg
    hi link EasyMotionShade  Comment
endfunction
function Layout_func()
    set nowrap
    set number
    set	showcmd 
    set	shiftwidth=4
    " set	softtabstop=4
    set expandtab " change tab into space
    " set modeline
    set	tabstop=4
    set	noeb ruler
    set	backspace=indent,eol,start
    set	history=60
    set wildmenu
    if has('gui_running')
        colors molokai
    else
        colorscheme desert
    endif

    " let g:molokai_original = 1
    " let g:rehash256 = 1
    set t_Co=256          " 256 color mode
    set cursorline        " highlight current line
    set wrap              " ‰∏çËá™Âä®Êç¢Ë°å
    set ruler             " show the cursor position all the time
    syntax on             " syntax highlight
    set hlsearch          " search highlighting
    set clipboard=unnamed " yank to the system register (*) by default
    set showmatch         " Cursor shows matching ) and }
    set showmode          " Show current mode
    set wildchar=<TAB>    " start wild expansion in the command line using <TAB>
    set incsearch         " incremental search . Show result before finished typing
    set nobackup          " no *~ backup files
    set noswapfile
    set ignorecase        " ignore case when searching
    set nowritebackup
    set smartcase         " ignore case if search pattern is all lowercase,case-sensitive otherwise
    set smarttab          " insert tabs on the start of a line according to context
    " ignore these files while expanding wild chars
    language mes en
    set wildignore=*.o,*.class
    " set ai          " auto indent
    set cindent
    "set smartindent
    " disable sound on errors
    set noerrorbells
    set visualbell
    set t_vb=
    set tm=500
    set laststatus=2
    filetype plugin on
    " These are files we are not likely to want to edit or read.
    set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
    syntax on
    filetype plugin indent on
    set nocompatible
    set go= "guioptions
    "set go+=m
    " set guioptions-=m  "remove menu bar
    " set guioptions-=T  "remove toolbar
    " set guioptions-=r  "remove right-hand scroll bar
    " set guioptions-=L  "remove left-hand scroll bar
endfunction
" fun! ViewUTF8()
" 	set encoding         =utf-8
" 	set termencoding     =big5
" endfun
" fun! UTF8()
" 	set encoding         =utf-8
" 	set termencoding     =big5
" 	set fileencoding     =utf-8
" 	set fileencodings    =ucs-bom,big5,utf-8,latin1
" endfun
" fun! Big5()
" 	set encoding         =big5
" 	set fileencoding     =big5
" endfun
function Encoding_func()
    set encoding=big5
    set termencoding=big5
    set fileencoding=big5
    set fileencodings=ucs-bom,utf-8,big5,gb2312,latin1,euc-jp,utf-bom,iso8859-1
endfunction
function! Browser ()
    let $PATH = $PATH . ';C:\Program Files (x86)\Google\Chrome\Application\'
    let line0 = getline (".")
    let line = matchstr (line0, "http[^ ]*")
    :if line==""
    let line = matchstr (line0, "ftp[^ ]*")
    :endif
    :if line==""
    let line = matchstr (line0, "file[^ ]*")
    :endif
    let line = escape (line, "#?&;|%")
    echo line
    exec ':silent !chrome.exe '. "\"" . line . "\""
endfunction
function Autocmd_func()
    set autoread		" auto read when file is changed from outside
    autocmd! bufwritepost .vimrc source ~/.vimrc " auto reload vimrc when editing it
    autocmd BufEnter * silent! lcd %:p:h
    " autocmd BufEnter * set nowrap
    "lcd : local cd
    "% : the name of the current file
    "%p : give its full path
    "%:p:h : its dir
endfunction
function! s:align()
    let p = '^\s*|\s.*\s|\s*$'
    if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
        let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
        let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
        Tabularize/|/l1
        normal! 0
        call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
    endif
endfunction
function Map_func()
    cmap cd. lcd %:p:h " :cd. change working directory to that of the current file
    map ,,w :call Browser ()<CR>
    nnoremap ,cd :cd %:p:h<CR>:pwd<CR>

    "Open in new tab (ctrl+t)
    map <silent> <C-E>  : browse tabnew<CR> 
    map ,<c-t> : tabnew<CR>
    " map <silent> ,,t   : browse tabnew<CR> 
    " Save all files
    map <silent> <C-S> : wa<CR> 
    imap <C-S> <ESC>   : wa<CR>
    "Close one tab
    map <C-q> :q!<CR>
    "Close one tab and save
    nmap zz            : wq!<CR>
    "Open one new empty tab
    "map <C-t> :tabnew<CR>
    "Close all tabs
    map ,qa            : qa!<CR>
    "quick fix moving
    map <leader>n      : cn<CR>
    map <leader>p      : cp<CR>
    "move back and forward around tabs
    map <S-H> gT
    map <S-L> gt
    nnoremap <silent> ,d :set operatorfunc=DeleteEmptyLines<CR>m"g@
    map <leader>c :call CalWordCount()<cr>
    nmap <Leader>db :g/^$/d<CR>
    imap ]] <ESC>:w<CR>
    nmap ]] <ESC>:w<CR>
    inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
endfunction
function SetFMDIndent()
    :set foldmethod=indent
endfunction
function Fold_func()
    set foldlevel=3 "Default level number
    set foldcolumn=2 "Default column number
endfunction
function Path_assign_func()
    set backupdir=$VIM\\BackUp
    set dir=$VIM\\BackUp
endfunction
function Supertab_func()
    let g:SuperTabMappingForward="<s-tab>"
    let g:SuperTabMappingBackward="<tab>"
    let g:SuperTabDefaultCompletionType = "context"
    "let g:SuperTabContextDefaultCompletionType = "<c-x><c-p>"
    "let g:SuperTabDefaultCompletionType = ‚Äò<C-X><C-U>
endfunction
function Complete_func()
    set completeopt=longest,menuone
    set thesaurus+=$VIM\word\test.txt
    set dictionary+=$VIM\word\wordsEn.txt
    set complete +=w,s,k,.,b,t
    " inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
    " inoremap <expr> <C-n> pumvisible() ? '<C-n>' : '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
    " inoremap <expr> <M-,> pumvisible() ? '<C-n>' : '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
    " inoremap <expr> <S-Space> (pumvisible() ? (col('.') > 1 ? '<Esc>i<Right>' : '<Esc>i') : '') . '<C-x><C-u><C-r>=pumvisible() ? "\<lt>C-n>\<lt>C-p>\<lt>Down>" : ""<CR>'
    " open user completion menu closing previous if open and opening new menu without changing the text
endfunction 
function Nerdtree_func ()
    nmap	<leader>e	:NERDTreeToggle<CR>
    let g:NERDTreeWinPos    = "right"
    let NERDTreeHijackNetrw = 0
endfunction 
function Ctrlp_func()
    noremap  <C-W><C-U> : CtrlPMRU <CR>
    " nnoremap  <C-W> u   : CtrlPMRU <CR>
    let g:ctrlp_custom_ignore         = '\.git$\|\.hg$\|\.svn$ \|.rvm$'
    let g:ctrlp_working_path_mode     = 0
    let g:ctrlp_match_window_bottom   = 1
    let g:ctrlp_max_height            = 15
    let g:ctrlp_match_window_reversed = 0
    let g:ctrlp_mruf_max              = 500
    let g:ctrlp_follow_symlinks       = 1
endfunction
function View_init()
    autocmd BufWinLeave *.* mkview
    autocmd BufWinEnter *.* silent loadview 
endfunction
function DragCurrentLineFunc()
    noremap  <A-j> :m+<CR>
    noremap  <A-k> :m-2<CR>
    inoremap <A-j> <Esc>:m+<CR>
    inoremap <A-k> <Esc>:m-2<CR>
    vnoremap <A-j> :m'>+<CR>gv
endfunction
function View_init_second()
    set viewoptions-=options
    augroup vimrc
        autocmd BufWritePost *
                    \   if expand('%') != '' && &buftype !~ 'nofile'
                    \|      mkview
                    \|  endif
        autocmd BufRead *
                    \   if expand('%') != '' && &buftype !~ 'nofile'
                    \|      silent loadview
                    \|  endif
    augroup END
endfunction
function DiffFunc()
    set diffexpr=
    map <silent> <C-V><C-F> :browse vert diffsplit<CR> " find one file to compare
endfunction
function TabularFunc()
    if exists(":Tabularize")
        nmap <Leader>a= :Tabularize /=<CR>
        vmap <Leader>a= :Tabularize /=<CR>
        nmap <Leader>a: :Tabularize /:\zs<CR>
        vmap <Leader>a: :Tabularize /:\zs<CR>
        ":Tab/:
        ":Tab/=
    endif
endfunction
function CommandLineFunc()
    " cnoremap <C-j> <t_kd>
    " cnoremap <C-k> <t_ku>
    " cnoremap <C-a> <Home>
    " cnoremap <C-e> <End>
    cmap <C-a> <Home>
    cmap <C-e> <End>
endfunction
function AckFunc()
    nmap	<leader>g:noautocmd ack /<C-R>=expand("<cword>")<CR>/ *.*<CR>
    nnoremap <C-H>  :noautocmd vimgrep /<C-R>=expand("<cword>")<CR>/ $solution_source_path<CR>:copen
    nnoremap <C-G>  :Ack <C-R>=expand("<cword>")<CR> 'D:\Code\DesignStudioNG\Source\' --type=csharp --type=cc --type=sql --type=vb
endfunction
function! NumberToggle()
    if(&relativenumber == 1)
        set number
    else
        set relativenumber
    endif
endfunc
function ShowLineFunc()
    " nnoremap <C-n> :call NumberToggle()<cr>
    au FocusLost * :set number
    au FocusGained * :set relativenumber
endfunction
function TagbarFunc()
    nmap <F7> <Esc>:!ctags -R *<CR>
    nmap <F8> :TagbarToggle<CR>
    let g:tagbar_left      = 1
    "set tags=..\..\tags,..\..\..\tags,.\tags
    set tags=D:\Code\DesignStudioNG\Source\tags
    let Tlist_Ctags_Cmd    = $VIM . '\vim74\ctags.exe'
    let g:tagbar_autofocus = 1
    nmap	,t	:Tlist<CR>
endfunction
function LayoutFunc()
    set guifont=Monaco:h10 
    :winpos 0 0
    set lines=999 columns=999
endfunction
function! CalWordCount()
    let l:cmd = []
    let l:cmd = add(l:cmd, '%s/')
    let l:cmd = add(l:cmd, '\(')
    let l:cmd = add(l:cmd, '[')
    let l:cmd = add(l:cmd, '\u3001-\u303f') 
    let l:cmd = add(l:cmd, '\u3040-\u309f')
    let l:cmd = add(l:cmd, '\u30a0-\u30ff')
    let l:cmd = add(l:cmd, '\u3100-\u312f')
    let l:cmd = add(l:cmd, '\u31a0-\u31bf')
    let l:cmd = add(l:cmd, '\u4e00-\u4eff\u4f00-\u4fff\u5000-\u50ff\u5100-\u51ff\u5200-\u52ff\u5300-\u53ff\u5400-\u54ff\u5500-\u55ff\u5600-\u56ff\u5700-\u57ff\u5800-\u58ff\u5900-\u59ff\u5a00-\u5aff\u5b00-\u5bff\u5c00-\u5cff\u5d00-\u5dff\u5e00-\u5eff\u5f00-\u5fff\u6000-\u60ff\u6100-\u61ff\u6200-\u62ff\u6300-\u63ff\u6400-\u64ff\u6500-\u65ff\u6600-\u66ff\u6700-\u67ff\u6800-\u68ff\u6900-\u69ff\u6a00-\u6aff\u6b00-\u6bff\u6c00-\u6cff\u6d00-\u6dff\u6e00-\u6eff\u6f00-\u6fff\u7000-\u70ff\u7100-\u71ff\u7200-\u72ff\u7300-\u73ff\u7400-\u74ff\u7500-\u75ff\u7600-\u76ff\u7700-\u77ff\u7800-\u78ff\u7900-\u79ff\u7a00-\u7aff\u7b00-\u7bff\u7c00-\u7cff\u7d00-\u7dff\u7e00-\u7eff\u7f00-\u7fff\u8000-\u80ff\u8100-\u81ff\u8200-\u82ff\u8300-\u83ff\u8400-\u84ff\u8500-\u85ff\u8600-\u86ff\u8700-\u87ff\u8800-\u88ff\u8900-\u89ff\u8a00-\u8aff\u8b00-\u8bff\u8c00-\u8cff\u8d00-\u8dff\u8e00-\u8eff\u8f00-\u8fff\u9000-\u90ff\u9100-\u91ff\u9200-\u92ff\u9300-\u93ff\u9400-\u94ff\u9500-\u95ff\u9600-\u96ff\u9700-\u97ff\u9800-\u98ff\u9900-\u99ff\u9a00-\u9aff\u9b00-\u9bff\u9c00-\u9cff\u9d00-\u9dff\u9e00-\u9eff\u9f00-\u9fff')
    let l:cmd = add(l:cmd, '\ufe10-\ufe1f')
    let l:cmd = add(l:cmd, '\uff00-\uffef')
    let l:cmd = add(l:cmd, ']')
    let l:cmd = add(l:cmd, '\|')
    let l:cmd = add(l:cmd, '\<\w*\>')
    let l:cmd = add(l:cmd, '\)')
    let l:cmd = add(l:cmd, '/&/gn')
    exe join(l:cmd, '')
    map c :call CalWordCount()
endfunction
function Complete_test_func()
    let g:neocomplcache_enable_at_startup = 1
endfunction
function BinaryViewFunc()
    nmap ,b  :%! xxd
    nmap ,br :%! xxd -r
endfunction
function! DeleteEmptyLines(type)
    if a:type == 'line'
        silent execute ".,'\"g/^$/d"
    endif
endfunction
function Airline_func()
    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tabline#left_sep = ' '
    let g:airline#extensions#tabline#left_alt_sep = '|'

    " enable tabline
    let g:airline#extensions#tabline#enabled = 1
    " set left separator
    let g:airline#extensions#tabline#left_sep = ' '
    " set left separator which are not editting
    let g:airline#extensions#tabline#left_alt_sep = '|'
    " show buffer number
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline_theme='wombat'

  let g:airline_section_b = '%{getcwd()}'
  "let g:airline_section_c = '%t'

  "let g:airline#extensions#tagbar#enabled = 1
  " let g:airline#extensions#tagbar#flags = ''
endfunction
function! AccentDemo()
  " let keys = ['a','b','c','d','e','f','g','h']
  " for k in keys
  "   call airline#parts#define_text(k, k)
  " endfor
  " call airline#parts#define_accent('a', 'red')
  " call airline#parts#define_accent('b', 'green')
  " call airline#parts#define_accent('c', 'blue')
  " call airline#parts#define_accent('d', 'yellow')
  " call airline#parts#define_accent('e', 'orange')
  " call airline#parts#define_accent('f', 'purple')
  " call airline#parts#define_accent('g', 'bold')
  " call airline#parts#define_accent('h', 'italic')
  let g:airline_section_a = 'GreatPeiKuan'
  "let g:airline_section_a = 'Øu®k§H'
endfunction
" execute functions
call ToggleVerbose()
call Airline_func()
call Vundle_func()
call BinaryViewFunc()
call TagbarFunc()
call DiffFunc()
call FontSizeSetting_func()
"call Pathogen_func()
call Autocmd_func()
call Fold_func()
call Path_assign_func()
" call Supertab_func()
call Complete_func()
call Nerdtree_func()
call View_init_second()
call Complete_test_func()
" call Bundle_func()
" call Vimwiki_func()
" call CommantT_func()
" call Snippet_func()
" call CompleteFunc()
" call ShowLineFunc()
call TabularFunc()
" call Encoding_func()
call CommandLineFunc()
call Layout_func()
" call EasyMotion_func()
call Win_short_cut_func()
call Map_func()
call Ctrlp_func()
call AckFunc()
call LayoutFunc()
call DragCurrentLineFunc()
call AddIndentFunc()
" call OmniSharpVimFunc()
" call SyntasticFunc()
set textwidth=300 
autocmd BufEnter *.* set nowrap
set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<


"tabo : close all tabs except the current one
"
autocmd VimEnter * call AccentDemo()
